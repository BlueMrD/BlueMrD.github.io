<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Django的login_required]]></title>
    <url>%2F2018%2F08%2F18%2FDjango%E7%9A%84login-required%2F</url>
    <content type="text"><![CDATA[如果是使用Django内置的auth实现的登录，对于Django网站的访问者，Django后台可以通过 request.user来查看访问者的身份。 现在我实现了一个项目的登录注册功能，项目首页网址为 /， 登录成功页面为/index 其中登录由auth实现的，我注册了一个名为’老狗’的用户，现在分别在登录以及未登录时访问该网站的首页。 12345678910111213141516# 首页def index(request): user = request.user # 查看访问者 print(user) if user: # 如果用户已注册并登录 if user.is_authenticated: post_list = Post.objects.all() # .order_by('-created_time') # 返回项目首页 return render(request, 'blog/index.html', context=&#123;'post_list': post_list&#125;) else: # 返回登录首页 return render(request, 'index.html', &#123;&#125;) return render(request, 'index.html') 未登录 AnonymousUser 代表匿名用户 已登录 上面的函数实现的功能：若是匿名函数，则将网页跳转到登录注册界面；若是已注册并登录的用户，则跳转到项目首页。 下面我们来使用Django内置函数login_required装饰器来实现上述功能。 1234567from django.contrib.auth.decorators import login_required# 首页@login_requireddef index(request): post_list = Post.objects.all() return render(request, 'blog/index.html', context=&#123;'post_list': post_list&#125;) 该装饰器表明该视图函数只有已登录用户才能访问，否则会跳转到其他页面，Django默认是/accounts/login/，可以在settings.py中自定义跳转页面 1LOGIN_URL = '/index' 步骤： ​ 使用django自带的装饰器 @login_required ​ 在相应的view方法的前面添加@login_required ​ 并在settings.py中自定义配置LOGIN_URL参数 如果想要跳转更为灵活，可以在装饰器中添加参数 123@login_required(login_url='/login', redirect_field_name='next')def index(request): pass login_url就是匿名用户访问后重定向的url，一般都是login的页面 redirect_field_name是一个get请求的参数 假设当前页面是/user/info/ 那么重定向的url为： /login/?next=/user/info/ 这个参数可以用于登陆后直接跳转回这个页面]]></content>
      <categories>
        <category>Programme</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Arcgis License Manager启动失败]]></title>
    <url>%2F2018%2F08%2F16%2FArcgis-License-Manager%E5%90%AF%E5%8A%A8%E5%A4%B1%E8%B4%A5%2F</url>
    <content type="text"><![CDATA[详情参考： Arcgis License Manager启动失败]]></content>
      <tags>
        <tag>Arcgis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从头开始学scrapy]]></title>
    <url>%2F2018%2F08%2F15%2F%E4%BB%8E%E5%A4%B4%E5%BC%80%E5%A7%8B%E5%AD%A6scrapy%2F</url>
    <content type="text"><![CDATA[创建虚拟环境参考 Python虚拟环境 Windows安装Scrapy参考 Scrapy安装 Scrapy 框架基本命令创建Scrapy项目 进入命令行，输入 1scrapy startproject '项目名' 创建spider蜘蛛 进入刚创建的Scrapy项目目录 12cd '项目名'scrapy genspider '蜘蛛名' 运行Scrapy项目 1scrapy crawl '蜘蛛名' 数据导出为json格式中文乱码问题导出为 json 格式命令 1scrapy crawl &apos;蜘蛛名&apos; -o &apos;文件名&apos;.json 导出为 csv 格式命令类似 在配置文件settings.py中添加 1FEED_EXPORT_ENCODING = 'utf-8']]></content>
      <categories>
        <category>Programme</category>
      </categories>
      <tags>
        <tag>Scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql数据库]]></title>
    <url>%2F2018%2F08%2F15%2FMysql%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[启动Mysql5.7进入命令行 1net start mysql57 1mysql -u root -p 输入密码即可。]]></content>
      <categories>
        <category>Database</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用faker大魔王创建user_agent]]></title>
    <url>%2F2018%2F08%2F15%2F%E4%BD%BF%E7%94%A8faker%E5%A4%A7%E9%AD%94%E7%8E%8B%E5%88%9B%E5%BB%BAuser-agent%2F</url>
    <content type="text"><![CDATA[在知道有 faker 这个库之后我就想用来写爬虫的用户池了，先在这里记录一下。 123456789101112from faker import Factory, Fakerfrom pprint import pprintfactory = Factory.create() # factory = Facker()print(factory.user_agent())print()UAPOOL = [factory.user_agent for i in range(50)]pprint(UAPOOL)]]></content>
      <categories>
        <category>Programme</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git生成SSH密匙]]></title>
    <url>%2F2018%2F08%2F14%2FGit%E7%94%9F%E6%88%90SSH%E5%AF%86%E5%8C%99%2F</url>
    <content type="text"><![CDATA[因为将hexo部署到github上需要ssh密匙，所以特地去学习了一下如何生成，记录在此，方便下次使用。 配置github账户信息在 Git Bash 下输入命令 1$ git config --global user.email &quot;YourName&quot; 1$ git config --global user.email &quot;YourEmail&quot; 其中的 YourName 与 YourEmail 都是你自己的github帐号与绑定邮箱。 创建SSH若之前没有创建过SSH密匙，则 在 Git Bash 下输入 1$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot; 引号的内容为邮箱地址。 查看SSH密匙如果已经生成了SSH密匙，可通过Git Bash命令进行查看 进入文件夹 1$ cd ~/.ssh 查看密匙 1$ cat id_rsa.pub]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建Django2.1]]></title>
    <url>%2F2018%2F08%2F12%2F%E6%90%AD%E5%BB%BADjango2-1%2F</url>
    <content type="text"><![CDATA[创建Django项目打开命令行，选择一个文件夹(我的直接放桌面上)，输入 1django-admin startproject &apos;项目名称&apos; 例： 文件目录列表为 创建并添加Django应用创建应用：命令行进入刚刚的django项目文件夹下，输入 1python mange.py startapp &apos;应用名称&apos; 例： 添加应用：打开mysite/mysite/settings.py文件 这一步相当于将应用注册到django中。 迁移数据库命令行输入 1python mange.py migrate 会在数据库中创建Django自带的数据表。 创建超级用户这一步是为了后面使用Django后台对数据进行操作，必须在迁移数据库之后才能进行。 命令行输入 1python mange.py createsuperuser 邮箱可以不输入，按Enter跳过，但密码并不是不输入，而是输入了也不显示。 运行django命令行输入 1python mange.py runserver 网站中输入 127.0.01:8000 即可看到项目运行成功。 Django后台登录创建超级用户后，运行Django项目，进入网址 127.0.0.1:8000/admin 登录成功 1 记得帐号，但是忘记了密码 命令行输入 1python manage.py changepassword &lt;username&gt; username 是你的帐号。 这些你都懂？ 那么请看下面 djano小技巧]]></content>
      <categories>
        <category>Programme</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django小技巧]]></title>
    <url>%2F2018%2F08%2F12%2FDjango%E5%B0%8F%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[Django项目设置中文与本地时区在项目下的 settings.py 文件中进行设置，将 改为 运行项目打开网址即可 关于外键从Django2.0版本开始，在类模型中，定义外键和一对一关系字段时需要添加 on_delete 参数，不然会报错：__init__() missing 1 required positional argument: &#39;on_delete&#39;。 后台显示中文应用名、类名与字段名如何登陆Django后台? Django后台登录 在添加Django应用后，创建超级管理员账号可以登录Django自带的管理后台，比如我添加了一个名为blog的应用，登录后台后显示为 现在我们来将它修改为中文显示 在Django应用目录(即你添加的应用)下打开apps.py文件，在AppNameConfig类里添加两条属性即可，如图： 然后在blog应用目录下的__init__.py文件里添加一句 1default_app_config = &apos;AppName.apps.AppNameConfig&apos; 即可 例如在我的应用下这一句应为 1default_app_config = &apos;blog.apps.BlogConfig&apos; 在上图中可以看到在博客应用下有三个Model，分别为Categorys，Tag和Posts，现在来改为中文显示。 在定义上面三个Model的models.py文件夹里，修改对应的model类，如下图所示： 后面两个修改方式一样，修改之后刷新后台。 在此说一下 verbose_name 与 verbose_name_plural 的区别：以 Categorys 为例，可以看到该Model名后面有个 &#39;s&#39;，意为复数，所以如果只添加 verbose_name = ‘分类’， 则在后台显示会为 ‘分类s’。 在models.py中的model类中，通常会创建一些字段，一般会想要这些字段在后台为中文显示，方便识别。 显示为中文方法很简单，在定义该字段时添加 verbose_name 参数即可，例如： 反向查询与数量统计我在 Django 里写了两个 Model，一个是 Post（文章），一个是 Comment（评论），两者是一对多关系 Post是Comment 的外键，如图： 在视图中如果需要取出一篇文章的全部评论，可以这样写 post= get_object_or_404(Post, pk=pk) comment_list = Comment.objects.filter(post=post) 这是从所有评论中选出属于 post 文章的评论 现在来看另一种方法，直接查询某篇文章所有属于它的评论 post = get_object_or_404(Post, pk=pk) comment_list = post.comment_set.all() 当然，我们一般会在文章页统计评论数，应该怎么做呢？ 在模板文件中使用 1&#123;&#123; post.comment_set.count &#125;&#125; 即可。 （模型管理器comment_set 是一个特殊的模型管理器）还有一个count方法，返回数量 使用 annotate 新定义了一个Model叫 Category作为Post，在 Post里添加一个外键字段 现在我想获取 属于同一分类 category下的所有 post，由前面所说的方法我可以在这样写 1234# 在 views.py 中category_list = Category.objects.all()# 在模板中&#123;&#123; category.post_set.count &#125;&#125; 但是这样的话每调用一次都会访问一次数据库，那么 annotate 就派上用场了 1234567# 在views.py中category_list = Category.objects.annotate(num_posts=Count('post'))# 在模板中&#123;% for category in category_list %&#125; &#123;&#123; category.num_posts &#125;&#125;&#123;% endfor %&#125; 使用 annotate 只需访问一次数据库就可以了。 模板文件、静态文件与媒体资源在 Django2.1 中，如果你将模板文件、静态文件与媒体资源放在应用下，则在访问资源时，会自动寻找，无须进行设置。 创建文件时，文件名是固定写法 123templates # 模板文件static # 静态文件media # 媒体资源文件 例：放在应用 blog 下的模板文件 如果需要放在项目目录下，则需在 settings.py中进行设置 模板文件 templates路径添加 12345678910111213141516TEMPLATES = [ &#123; 'BACKEND': 'django.template.backends.django.DjangoTemplates', -'DIRS': [], +'DIRS': [os.path.join(BASE_DIR, 'templates')], 'APP_DIRS': True, 'OPTIONS': &#123; 'context_processors': [ 'django.template.context_processors.debug', 'django.template.context_processors.request', 'django.contrib.auth.context_processors.auth', 'django.contrib.messages.context_processors.messages', ], &#125;, &#125;,] 静态文件路径添加，在 settings.py 中的末尾添加 12345STATIC_PATH = os.path.join(BASE_DIR, 'static')STATICFILES_DIRS = ( STATIC_PATH,) 媒体资源路径添加 12MEDIA_URL = '/media/'MEDIA_ROOT = os.path.join(BASE_DIR, 'media') app应用设计开发环境在PyCharm下。 若一个django项目下有许多个app应用，那么我们肯定想要将他们它们放入同一个文件夹下，方便管理。 例： 我的django项目下有三个 appp应用，blog、users和comments 在项目目录下新建一个python package ，命名为 apps，将三个应用全部放入其中。 此时运行项目会报错，右键 apps 文件移到最下面选择 Mark Directory as点击Source Root，并在settings.py中设置 再次运行项目，就会成功了。 自定义模板标签django的模板标签自定义 models.py 123456789101112131415161718from django.db import models# Create your models here.# 分类class Category(models.Model): pass# 标签class Tag(models.Model): pass# 文章class Post(models.Model): pass 在应用目录下创建python package，名字必须为templatetags， 在该python包下自定义文件blog_tags.py 123456789101112131415161718192021222324252627282930313233343536# -*-coding:utf-8-*-# blog_tags.py__Author__ = "Mr.D"__Date__ = '2018\8\14 0014 21:26'from ..models import Post, Category, Tagfrom django import templateregister = template.Library()# 将该函数注册为模板标签，可通过&#123;% get_recent_posts %&#125;语法在模板中调用# 最新文章@register.simple_tagdef get_recent_posts(num=5): return Post.objects.all().order_by('-created_time')[:num]# 归档@register.simple_tagdef archives(): return Post.objects.dates('created_time', 'month', order='DESC')# 分类@register.simple_tagdef get_categories(): return Category.objects.all()@register.simple_tagdef get_tags(): return Tag.objects.all() 通过此方法可使上面三个函数作为模板语言在django模板中使用，在模板文件中导入 1&#123;% load blog_tags %&#125; 即可。 使用方法与一般模板语言一样。 自定义Django admin修改项目admin后台的 header 与 title 在 应用（任意一个）下的admin.py中添加 12admin.site.site_header = 'Black &amp; White'admin.site.site_title = admin.site.site_header 刷新一下后台 Django ORM 查询语句12345678# __gt 大于Model.objects.filter(count__gt=0)# __gte 大于等于Model.objects.filter(count__gte=0)# lt 小于Model.objects.filter(count__lt=0)# lte 小于等于Model.objects.filter(count__lte=0)]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo搭建博客错误解决]]></title>
    <url>%2F2018%2F08%2F06%2FHexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3%2F</url>
    <content type="text"><![CDATA[使用hexo搭建个人博客的过程中碰到了好多的坑，现在一一填上。 hexo的下载安装可参考 hexo安装 Hexo常用命令1234567891011# 创建文章$ hexo new &apos;xxx&apos;# 创建标签$ hexo new page tags# 创建分类$ hexo new page categories# 调试命令$ hexo s ## hexo s -p 5000 更换端口 在文章中插图片必须配置： 1 把主页配置文件_config.yml 里的post_asset_folder:这个选项设置为true 2 在你的hexo目录下执行这样一句话npm install hexo-asset-image --save，这是下载安装一个可以上传本地图片的插件。 3 运行hexo n &quot;xxxx&quot;来生成md博文时，/source/_posts文件夹内除了xxxx.md文件还有一个同名的文件夹。 两种方法： 1 使用Markdown 语法 1![对该图片的描述](同名文件夹名/图片名.jpg) 2 使用hexo自带插件 1&#123;% asset_img 图片名.png/jpg 对图片的描述写在这哦 %&#125; github仓库名必须与github用户名一致 使用 hexo s 时本地不显示博客内容，而显示 cannot get/xxx1$ hexo s -p 5000 换个端口即可。 设置语言为中文我最开始按照网站教程在站点配置文件_config.yml下的设置语言为中文 1language: zh-Hans 然而本地网站并没有换成中文。 因为在hexo的新版本中被更换了，改成 1language: zh-CN 即可。 配置LeanCloud，将阅读人数替换为热度参考： 配置LeanCloud 然而进入文章会出现这样的错误 &quot;Counter not initialized! See more at console err msg&quot; 解决方法参考：LearnCloud报错解决 添加阅读时长和本文字数博文压缩安装 gulp以及依赖包 123$ npm install --save-dev babel-cli$ npm install --save-dev babel-preset-es2015$ npm install gulp-minify-css gulp-babel gulp-uglify gulp-htmlmin gulp-htmlclean --save-dev 在博客的根目录创建新文件 gulpfile.js，添加如下代码 12345678910111213141516171819202122232425262728293031323334var gulp = require('gulp');var minifycss = require('gulp-minify-css');var babel = require('gulp-babel');var uglify = require('gulp-uglify');var htmlmin = require('gulp-htmlmin');var htmlclean = require('gulp-htmlclean');gulp.task('minify-css', function () &#123;return gulp.src('./public/**/*.css').pipe(minifycss()).pipe(gulp.dest('./public'));&#125;);gulp.task('minify-html', function () &#123;return gulp.src('./public/**/*.html').pipe(htmlclean()).pipe(htmlmin(&#123;removeComments: true,minifyJS: true,minifyCSS: true,minifyURLs: true,&#125;)).pipe(gulp.dest('./public'))&#125;);gulp.task('minify-js', function () &#123;return gulp.src(['./public/**/*.js', '!./public/**/*.min.js']).pipe(babel(&#123; presets: ['es2015'] &#125;)).pipe(uglify()).pipe(gulp.dest('./public'));&#125;);gulp.task('default', ['minify-html', 'minify-css', 'minify-js']); 执行 hexo g 产生编译文件之后，执行 gulp进行压缩，以下信息代表压缩成功 再执行 hexo d部署到服务器上即可。]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F08%2F06%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
