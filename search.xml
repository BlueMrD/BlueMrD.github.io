<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[requests+gevent异步爬虫]]></title>
    <url>%2F2018%2F08%2F26%2Frequests-gevent%E5%BC%82%E6%AD%A5%E7%88%AC%E8%99%AB%2F</url>
    <content type="text"><![CDATA[猴子补丁由于requests不是非阻塞的，所以需要通过gevent 给其打上一个猴子补丁来实现非阻塞。 `from gevent import monkey; monkey.path_all 简单示例通过一个简单的例子来说明 requests 加 gevent如何实现异步爬虫 12345678910111213141516171819202122from gevent import monkey; monkey.path_all()import requestsimport geventimport timedef f(url): print(url) data = requests.get(url) print(data) start = time.time()url = 'http://www.baidu.com/'url_list = []for i in range(5): url_list.append(gevent.spawn(f, url)) gevent.joinall(url_list)print(time.time()-start) 同步的时候需要 0.3~0.4s，这是请求数只有 5的时候，当请求数达到1000的时候，同步爬虫耗时是异步的两倍，可以自行测试一下。]]></content>
      <categories>
        <category>Programme</category>
      </categories>
      <tags>
        <tag>spider</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django博客基于CBV限制用户访问及重定向]]></title>
    <url>%2F2018%2F08%2F23%2FDjango%E5%8D%9A%E5%AE%A2%E5%9F%BA%E4%BA%8ECBV%E9%99%90%E5%88%B6%E7%94%A8%E6%88%B7%E8%AE%BF%E9%97%AE%E5%8F%8A%E9%87%8D%E5%AE%9A%E5%90%91%2F</url>
    <content type="text"><![CDATA[基于FBV模式最开始的视图函数是基于FBV模式下实现的限制用户访问及重定向，代码如下： 12345678from django.contrib.auth.decorators import login_requred@login_required(login_url='/users/login', redirect_field_name='next')def index(request): post_list = Post.objects.all() page = request.GET.get('page', '1') data = get_page_data(post_list, page) return render(request, 'blog/index.html', context=data) 原理可以参考我的这篇文章 login_required介绍 基于CBV模式今天优化了一下 views.py 里的代码，改为通用视图来实现，index函数代码改为： 12345678910111213from django.contrib.auth import login_requiredfrom django.views.generic import ListViewclass IndexView(ListView): model = Post template_name = 'blog/index.html' context_object_name = 'post_list' paginate_by = 1 @classmethod def as_view(cls, **initkwargs): view = super().as_view(**initkwargs) return login_required(view, login_url='/users/login', redirect_field_name='next') 参考： django 限制匿名用户访问以及重定向 Django中login_required装饰器的深入介绍]]></content>
      <categories>
        <category>Programme</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django博客基于FBV实现分页功能]]></title>
    <url>%2F2018%2F08%2F23%2FDjango%E5%8D%9A%E5%AE%A2%E5%9F%BA%E4%BA%8EFBV%E5%AE%9E%E7%8E%B0%E5%88%86%E9%A1%B5%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[本文的博客项目搭建基于追梦人物的博客教程，我的项目是将前面两个教程结合起来写的一个博客。 本文来谈谈如何基于 Django的FBV来实现教程里的分页功能 分析代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138blog/views.pyclass IndexView(ListView): model = Post template_name = 'blog/index.html' context_object_name = 'post_list' paginate_by = 10 def get_context_data(self, **kwargs): """ 在视图函数中将模板变量传递给模板是通过给 render 函数的 context 参数传递一个字典实现的， 例如 render(request, 'blog/index.html', context=&#123;'post_list': post_list&#125;)， 这里传递了一个 &#123;'post_list': post_list&#125; 字典给模板。 在类视图中，这个需要传递的模板变量字典是通过 get_context_data 获得的， 所以我们复写该方法，以便我们能够自己再插入一些我们自定义的模板变量进去。 """ # 首先获得父类生成的传递给模板的字典。 context = super().get_context_data(**kwargs) # 父类生成的字典中已有 paginator、page_obj、is_paginated 这三个模板变量， # paginator 是 Paginator 的一个实例， # page_obj 是 Page 的一个实例， # is_paginated 是一个布尔变量，用于指示是否已分页。 # 例如如果规定每页 10 个数据，而本身只有 5 个数据，其实就用不着分页，此时 is_paginated=False。 # 关于什么是 Paginator，Page 类在 Django Pagination 简单分页：http://zmrenwu.com/post/34/ 中已有详细说明。 # 由于 context 是一个字典，所以调用 get 方法从中取出某个键对应的值。 paginator = context.get('paginator') page = context.get('page_obj') is_paginated = context.get('is_paginated') # 调用自己写的 pagination_data 方法获得显示分页导航条需要的数据，见下方。 pagination_data = self.pagination_data(paginator, page, is_paginated) # 将分页导航条的模板变量更新到 context 中，注意 pagination_data 方法返回的也是一个字典。 context.update(pagination_data) # 将更新后的 context 返回，以便 ListView 使用这个字典中的模板变量去渲染模板。 # 注意此时 context 字典中已有了显示分页导航条所需的数据。 return context def pagination_data(self, paginator, page, is_paginated): if not is_paginated: # 如果没有分页，则无需显示分页导航条，不用任何分页导航条的数据，因此返回一个空的字典 return &#123;&#125; # 当前页左边连续的页码号，初始值为空 left = [] # 当前页右边连续的页码号，初始值为空 right = [] # 标示第 1 页页码后是否需要显示省略号 left_has_more = False # 标示最后一页页码前是否需要显示省略号 right_has_more = False # 标示是否需要显示第 1 页的页码号。 # 因为如果当前页左边的连续页码号中已经含有第 1 页的页码号，此时就无需再显示第 1 页的页码号， # 其它情况下第一页的页码是始终需要显示的。 # 初始值为 False first = False # 标示是否需要显示最后一页的页码号。 # 需要此指示变量的理由和上面相同。 last = False # 获得用户当前请求的页码号 page_number = page.number # 获得分页后的总页数 total_pages = paginator.num_pages # 获得整个分页页码列表，比如分了四页，那么就是 [1, 2, 3, 4] page_range = paginator.page_range if page_number == 1: # 如果用户请求的是第一页的数据，那么当前页左边的不需要数据，因此 left=[]（已默认为空）。 # 此时只要获取当前页右边的连续页码号， # 比如分页页码列表是 [1, 2, 3, 4]，那么获取的就是 right = [2, 3]。 # 注意这里只获取了当前页码后连续两个页码，你可以更改这个数字以获取更多页码。 right = page_range[page_number:page_number + 2] # 如果最右边的页码号比最后一页的页码号减去 1 还要小， # 说明最右边的页码号和最后一页的页码号之间还有其它页码，因此需要显示省略号，通过 right_has_more 来指示。 if right[-1] &lt; total_pages - 1: right_has_more = True # 如果最右边的页码号比最后一页的页码号小，说明当前页右边的连续页码号中不包含最后一页的页码 # 所以需要显示最后一页的页码号，通过 last 来指示 if right[-1] &lt; total_pages: last = True elif page_number == total_pages: # 如果用户请求的是最后一页的数据，那么当前页右边就不需要数据，因此 right=[]（已默认为空）， # 此时只要获取当前页左边的连续页码号。 # 比如分页页码列表是 [1, 2, 3, 4]，那么获取的就是 left = [2, 3] # 这里只获取了当前页码后连续两个页码，你可以更改这个数字以获取更多页码。 left = page_range[(page_number - 3) if (page_number - 3) &gt; 0 else 0:page_number - 1] # 如果最左边的页码号比第 2 页页码号还大， # 说明最左边的页码号和第 1 页的页码号之间还有其它页码，因此需要显示省略号，通过 left_has_more 来指示。 if left[0] &gt; 2: left_has_more = True # 如果最左边的页码号比第 1 页的页码号大，说明当前页左边的连续页码号中不包含第一页的页码， # 所以需要显示第一页的页码号，通过 first 来指示 if left[0] &gt; 1: first = True else: # 用户请求的既不是最后一页，也不是第 1 页，则需要获取当前页左右两边的连续页码号， # 这里只获取了当前页码前后连续两个页码，你可以更改这个数字以获取更多页码。 left = page_range[(page_number - 3) if (page_number - 3) &gt; 0 else 0:page_number - 1] right = page_range[page_number:page_number + 2] # 是否需要显示最后一页和最后一页前的省略号 if right[-1] &lt; total_pages - 1: right_has_more = True if right[-1] &lt; total_pages: last = True # 是否需要显示第 1 页和第 1 页后的省略号 if left[0] &gt; 2: left_has_more = True if left[0] &gt; 1: first = True data = &#123; 'left': left, 'right': right, 'left_has_more': left_has_more, 'right_has_more': right_has_more, 'first': first, 'last': last, &#125; return data 这是教程里基于CBV实现分页功能的代码。 分析上述代码，我们可以自己写一个函数实现分页功能 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677from django.core.paginator import Paginator, PageNotAnInteger, EmptyPagedef get_page_data(obj_list, page): # 定义 paginator paginator = Paginator(obj_list, 1) try: post = paginator.page(page) except PageNotAnInteger: post = paginator.page(1) except EmptyPage: post = paginator.page(paginator.num_pages) left = [] right = [] left_has_more = False right_has_more = False first = False last = False # 这里的 page_number 需自定义 page_number = post.number total_pages = paginator.num_pages # 这里的 is_paginated 需自定义，类视图函数里的方法里已经实现，无须定义 is_paginated = bool(total_pages &gt; 2) page_range = paginator.page_range if page_number == 1: right = page_range[page_number:page_number + 2] if right[-1] &lt; total_pages - 1: right_has_more = True if right[-1] &lt; total_pages: last = True elif page_number == total_pages: left = page_range[(page_number - 3) if (page_number - 3) &gt; 0 else 0:page_number - 1] if left[0] &gt; 2: left_has_more = True if left[0] &gt; 1: first = True else: left = page_range[(page_number - 3) if (page_number - 3) &gt; 0 else 0:page_number - 1] right = page_range[page_number:page_number + 2] if right[-1] &lt; total_pages - 1: right_has_more = True if right[-1] &lt; total_pages: last = True if left[0] &gt; 2: left_has_more = True if left[0] &gt; 1: first = True data = &#123; 'is_paginated': is_paginated, 'post': post, 'left': left, 'right': right, 'left_has_more': left_has_more, 'right_has_more': right_has_more, 'first': first, 'last': last, 'paginator': paginator, &#125; return data paginator、is_paginated 和page.obj(三个参数在模板中的名字也是一样)在基于 CBV 来实现分页时，类方法 get_context_data(self, **kwargs)返回的对象中已经包含有，但是基于 FBV 时需要自己定义才行，所以上面的函数中，通过自定义paginator、is_paginated和post（对应page.obj）来获取三个参数，而其他地方几乎没有改动。 为什么要单独写成函数而不是写在视图函数下呢？ 原因有两个： ​ 一是因为代码有点多，所有抽象出来，方便使用。 ​ 二是不仅一个视图函数里需要实现分页功能，所以抽象出来封装成函数更加方便。 我将这个函数写入了 blog/pagetor.py 中，然后在blog/views中导入该函数。 使用方法]]></content>
      <categories>
        <category>Programme</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Scrapy调试方法]]></title>
    <url>%2F2018%2F08%2F22%2FScrapy%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Scrapy shell我们可以使用Scrapy shell来进行调试，以&quot;http://gz.ziroom.com/z/nl/z2.html&quot;为例 1scrapy shell "http://gz.ziroom.com/z/nl/z2.html" 如果你安装了 ipython， 那么它将会是你熟悉的样子 你也可以这样，输入scrapy shell进入shell下之后再输入 fetch(&quot;http://gz.ziroom.com/z/nl/z2.html&quot;) 我们可以查看response的各个属性 接下来在 shell里对返回的 response对象进行解析 若想对url填加 headers 也是可以实现的]]></content>
      <categories>
        <category>Programme</category>
      </categories>
      <tags>
        <tag>Scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Scrapy spider类传参(更换爬取网站)]]></title>
    <url>%2F2018%2F08%2F21%2FScrapy-spider%E7%B1%BB%E4%BC%A0%E5%8F%82-%E6%9B%B4%E6%8D%A2%E7%88%AC%E5%8F%96%E7%BD%91%E7%AB%99%2F</url>
    <content type="text"><![CDATA[自定义初始化方法新建一个Scrapy的spider的时候，spider文件大概是这样的 1234567891011import scrapyclass MySpider(scrapy.Spider): # 爬虫名字，重要 name = 'spider.name' allow_domains = ['website.com'] start_urls = ['http://website.com/a/b'] def parse(self, response): pass 我想要爬取的网址都放在start_urls中，它会一一进行爬取。 现在我想要通过传递参数来更换我想爬取的网址，重写Myspider类的初始化方法就可以啦 下面来举例说明 爬取腾讯股票 上面是我做的爬取 http://quotes.money.163.com/hkstock/cwsj_00700.html 的Scrapy爬虫， spider文件的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445# -*-coding:utf-8-*- from scrapy.spiders import Spiderfrom scrapy.http import Requestfrom scrapy.selector import Selectorfrom Mycrawl.items import GupiaoItem class MovieSpider(Spider): # 爬虫名字，重要 name = 'gupiao' allow_domains = ['quotes.money.163.com'] start_urls = ['http://quotes.money.163.com/hkstock/cwsj_00700.html'] def parse(self, response): item = GupiaoItem() selector = Selector(response) datas = selector.xpath('//table[@class="mod-table2 column"]') contents = selector.xpath('//table[@class="mod-table2 thWidth205"]') titles = selector.xpath('//div[@class="titlebar3"]/span/text()').extract() # 共四张表，i 从 0 开始 for i, each1 in enumerate(contents): # 第 i+1 张表的第二列所有数据 content1 = each1.xpath('tbody/tr/td[1]/div') # 第 i+1 张表的第三列所有数据 content2 = each1.xpath('tbody/tr/td[2]/div') # 第 i+1 张表的第四列所有数据 content3 = each1.xpath('tbody/tr/td[3]/div') # 第 i+1 张表的第一列所有数据 data = datas[i].xpath('tr/td') for j, each2 in enumerate(data): name = each2.xpath('text()').extract() frist = content1[j].xpath('text()').extract() second = content2[j].xpath('text()').extract() thrid = content3[j].xpath('text()').extract() item['title'] = titles[i] item['dataname'] = name[0] item['fristdata'] = frist[0] item['secondata'] = second[0] item['thridata'] = thrid[0] yield item 现在我想爬取 http://quotes.money.163.com/hkstock/cwsj_00800.html 的信息，我可以将这个网址放入start_urls里进行爬取，这是一种方法。 我们可以看到，两个网址之间的差别就是后面的 5 个数字不一样而已，如果我只想更换这 5 个数字来进行爬取，该怎么做？ 可以这样写 1234567891011121314151617class MovieSpider(Spider): # 爬虫名字，重要 name = 'gupiao' # allow_domains = ['quotes.money.163.com'] start_urls = ['http://quotes.money.163.com/hkstock/cwsj_00700.html'] def __init__(self, key=None, *args, **kwargs): super(MovieSpider, self).__init__(*args, **kwargs) length = len(key) if length == 5: myurl = 'http://quotes.money.163.com/hkstock/cwsj_&#123;&#125;.html'.format(key) elif length &gt; 5: myurl = key else: myurl = 'http://quotes.money.163.com/hkstock/cwsj_00700.html' print('要爬取的网址为：&#123;&#125;'.format(myurl)) self.start_urls = [myurl] 这段代码的意思很简单，就是即可以传入 5 个数字来进行更换网址，也可以通过传入完整的网址来进行更换，运行Scrapy时传递参数的方法如下 1scrapy crawl gupiao key=00800 --nolog 也可以 1scrapy crawl gupiao key=http://quotes.money.163.com/hkstock/cwsj_00800.html --nolog 让我们来看看结果吧 数据库的结果]]></content>
      <categories>
        <category>Programme</category>
      </categories>
      <tags>
        <tag>scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Xpath提取多标签下的所有文字(text)]]></title>
    <url>%2F2018%2F08%2F21%2FXpath%E6%8F%90%E5%8F%96%E5%A4%9A%E6%A0%87%E7%AD%BE%E4%B8%8B%E7%9A%84%E6%89%80%E6%9C%89%E6%96%87%E5%AD%97-text%2F</url>
    <content type="text"><![CDATA[提取方法昨天做 58租房 爬虫，有个标签类似于这样的 12345678910&lt;div id="test3"&gt;我左青龙， &lt;span id="tiger"&gt;右白虎。&lt;/span&gt; &lt;ul&gt;上朱雀， &lt;li&gt;下玄武。&lt;/li&gt; &lt;/ul&gt; &lt;ul&gt; 老牛在当中， &lt;/ul&gt; &lt;span&gt;龙头在胸口。&lt;/span&gt;&lt;/div&gt; 好吧，其实没这么复杂。不过我只是举个例子而已。 显而易见，上面 html 中的文字是一句话，可是却分别在不同的标签下，Xpath有个快捷的方式来实现提取。 1234567891011121314151617from lxml import etreehtml = '''&lt;div id="test3"&gt;我左青龙， &lt;span id="tiger"&gt;右白虎。&lt;/span&gt; &lt;ul&gt;上朱雀， &lt;li&gt;下玄武。&lt;/li&gt; &lt;/ul&gt; &lt;ul&gt; 老牛在当中， &lt;/ul&gt; &lt;span&gt;龙头在胸口。&lt;/span&gt;&lt;/div&gt;'''html = etree.HTML(html)data = html.xpath('string(.)') 打印 去掉空格和换行美化一下 12data = data.replace(' ', '').replace('\n', '')print(data)]]></content>
      <categories>
        <category>Programme</category>
      </categories>
      <tags>
        <tag>Spider</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django2.1集成simditor编辑器]]></title>
    <url>%2F2018%2F08%2F20%2FDjango2-1%E9%9B%86%E6%88%90simditor%E7%BC%96%E8%BE%91%E5%99%A8%2F</url>
    <content type="text"><![CDATA[Django后台admin集成simditor编辑器所需依赖包12pip intall django-simditorpip install pillow 具体配置settings.py 12345678910111213141516171819202122232425262728293031323334353637import tempfileINSTALLED_APPS = [ &apos;django.contrib.admin&apos;, &apos;django.contrib.auth&apos;, &apos;django.contrib.contenttypes&apos;, &apos;django.contrib.sessions&apos;, &apos;django.contrib.messages&apos;, &apos;django.contrib.staticfiles&apos;, &apos;simditor&apos;]# 这两句必须添加，否则运行时会报错，官方文档没有说明MEDIA_URL = &apos;/media/&apos;MEDIA_ROOT = os.path.join(tempfile.gettempdir(), &apos;sm_media&apos;)SIMDITOR_UPLOAD_PATH = &apos;uploads/&apos;SIMDITOR_IMAGE_BACKEND = &apos;pillow&apos;SIMDITOR_TOOLBAR = [ &apos;title&apos;, &apos;bold&apos;, &apos;italic&apos;, &apos;underline&apos;, &apos;strikethrough&apos;, &apos;fontScale&apos;, &apos;color&apos;, &apos;|&apos;, &apos;ol&apos;, &apos;ul&apos;, &apos;blockquote&apos;, &apos;code&apos;, &apos;table&apos;, &apos;|&apos;, &apos;link&apos;, &apos;image&apos;, &apos;hr&apos;, &apos;|&apos;, &apos;indent&apos;, &apos;outdent&apos;, &apos;alignment&apos;, &apos;fullscreen&apos;, &apos;markdown&apos;, &apos;emoji&apos;]SIMDITOR_CONFIGS = &#123; &apos;toolbar&apos;: SIMDITOR_TOOLBAR, &apos;upload&apos;: &#123; &apos;url&apos;: &apos;/simditor/upload/&apos;, &apos;fileKey&apos;: &apos;upload&apos; &#125;, &apos;emoji&apos;: &#123; &apos;imagePath&apos;: &apos;/static/simditor/images/emoji/&apos; &#125;&#125; 使用方法12# 创建应用apppython manage.py startapp blog settings.py 1234567891011INSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'simditor', 'blog',] models.py 1234567891011from django.db import modelsfrom simditor.fields import RichTextFieldclass Post(models.Model): title = models.CharField(verbose_name=&apos;标题&apos;, max_length=50) content = RichTextField(verbose_name=&apos;内容&apos;) class Meta: verbose_name = &apos;文章&apos; verbose_name_plural = verbose_name admin.py 1234567from django.contrib import adminfrom .models import Post# Register your models here.admin.site.register(Post) 迁移数据库 12python manage.py makemigrationspython manage.py migrate 运行项目 1python manage.py runserver 登录后台]]></content>
      <categories>
        <category>Programme</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django的login_required]]></title>
    <url>%2F2018%2F08%2F18%2FDjango%E7%9A%84login-required%2F</url>
    <content type="text"><![CDATA[如果是使用Django内置的auth实现的登录，对于Django网站的访问者，Django后台可以通过 request.user来查看访问者的身份。 现在我实现了一个项目的登录注册功能，项目首页网址为 /， 登录成功页面为/index 其中登录由auth实现的，我注册了一个名为’老狗’的用户，现在分别在登录以及未登录时访问该网站的首页。 12345678910111213141516# 首页def index(request): user = request.user # 查看访问者 print(user) if user: # 如果用户已注册并登录 if user.is_authenticated: post_list = Post.objects.all() # .order_by('-created_time') # 返回项目首页 return render(request, 'blog/index.html', context=&#123;'post_list': post_list&#125;) else: # 返回登录首页 return render(request, 'index.html', &#123;&#125;) return render(request, 'index.html') 未登录 AnonymousUser 代表匿名用户 已登录 上面的函数实现的功能：若是匿名函数，则将网页跳转到登录注册界面；若是已注册并登录的用户，则跳转到项目首页。 下面我们来使用Django内置函数login_required装饰器来实现上述功能。 1234567from django.contrib.auth.decorators import login_required# 首页@login_requireddef index(request): post_list = Post.objects.all() return render(request, 'blog/index.html', context=&#123;'post_list': post_list&#125;) 该装饰器表明该视图函数只有已登录用户才能访问，否则会跳转到其他页面，Django默认是/accounts/login/，可以在settings.py中自定义跳转页面 1LOGIN_URL = '/index' 步骤： ​ 使用django自带的装饰器 @login_required ​ 在相应的view方法的前面添加@login_required ​ 并在settings.py中自定义配置LOGIN_URL参数 如果想要跳转更为灵活，可以在装饰器中添加参数 123@login_required(login_url='/login', redirect_field_name='next')def index(request): pass login_url就是匿名用户访问后重定向的url，一般都是login的页面 redirect_field_name是一个get请求的参数 假设当前页面是/user/info/ 那么重定向的url为： /login/?next=/user/info/ 这个参数可以用于登陆后直接跳转回这个页面 更多信息请参考 django 限制匿名用户访问以及重定向]]></content>
      <categories>
        <category>Programme</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Arcgis License Manager启动失败]]></title>
    <url>%2F2018%2F08%2F16%2FArcgis-License-Manager%E5%90%AF%E5%8A%A8%E5%A4%B1%E8%B4%A5%2F</url>
    <content type="text"><![CDATA[详情参考： Arcgis License Manager启动失败]]></content>
      <tags>
        <tag>Arcgis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从头开始学scrapy]]></title>
    <url>%2F2018%2F08%2F15%2F%E4%BB%8E%E5%A4%B4%E5%BC%80%E5%A7%8B%E5%AD%A6scrapy%2F</url>
    <content type="text"><![CDATA[创建虚拟环境参考 Python虚拟环境 Windows安装Scrapy参考 Scrapy安装 Scrapy 框架基本命令创建Scrapy项目 进入命令行，输入 1scrapy startproject '项目名' 创建spider蜘蛛 进入刚创建的Scrapy项目目录 12cd '项目名'scrapy genspider '蜘蛛名' 运行Scrapy项目 1scrapy crawl '蜘蛛名' 数据导出为json格式中文乱码问题导出为 json 格式命令 1scrapy crawl &apos;蜘蛛名&apos; -o &apos;文件名&apos;.json 导出为 csv 格式命令类似 在配置文件settings.py中添加 1FEED_EXPORT_ENCODING = 'utf-8']]></content>
      <categories>
        <category>Programme</category>
      </categories>
      <tags>
        <tag>Scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql数据库]]></title>
    <url>%2F2018%2F08%2F15%2FMysql%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[启动Mysql5.7进入命令行 1net start mysql57 1mysql -u root -p 输入密码即可。]]></content>
      <categories>
        <category>Database</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用faker大魔王创建user_agent]]></title>
    <url>%2F2018%2F08%2F15%2F%E4%BD%BF%E7%94%A8faker%E5%A4%A7%E9%AD%94%E7%8E%8B%E5%88%9B%E5%BB%BAuser-agent%2F</url>
    <content type="text"><![CDATA[在知道有 faker 这个库之后我就想用来写爬虫的用户池了，先在这里记录一下。 123456789101112from faker import Factory, Fakerfrom pprint import pprintfactory = Factory.create() # factory = Facker()print(factory.user_agent())print()UAPOOL = [factory.user_agent for i in range(50)]pprint(UAPOOL)]]></content>
      <categories>
        <category>Programme</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git生成SSH密匙]]></title>
    <url>%2F2018%2F08%2F14%2FGit%E7%94%9F%E6%88%90SSH%E5%AF%86%E5%8C%99%2F</url>
    <content type="text"><![CDATA[因为将hexo部署到github上需要ssh密匙，所以特地去学习了一下如何生成，记录在此，方便下次使用。 配置github账户信息在 Git Bash 下输入命令 1$ git config --global user.email &quot;YourName&quot; 1$ git config --global user.email &quot;YourEmail&quot; 其中的 YourName 与 YourEmail 都是你自己的github帐号与绑定邮箱。 创建SSH若之前没有创建过SSH密匙，则 在 Git Bash 下输入 1$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot; 引号的内容为邮箱地址。 查看SSH密匙如果已经生成了SSH密匙，可通过Git Bash命令进行查看 进入文件夹 1$ cd ~/.ssh 查看密匙 1$ cat id_rsa.pub]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建Django2.1]]></title>
    <url>%2F2018%2F08%2F12%2F%E6%90%AD%E5%BB%BADjango2-1%2F</url>
    <content type="text"><![CDATA[创建Django项目打开命令行，选择一个文件夹(我的直接放桌面上)，输入 1django-admin startproject &apos;项目名称&apos; 例： 文件目录列表为 创建并添加Django应用创建应用：命令行进入刚刚的django项目文件夹下，输入 1python mange.py startapp &apos;应用名称&apos; 例： 添加应用：打开mysite/mysite/settings.py文件 这一步相当于将应用注册到django中。 迁移数据库命令行输入 1python mange.py migrate 会在数据库中创建Django自带的数据表。 创建超级用户这一步是为了后面使用Django后台对数据进行操作，必须在迁移数据库之后才能进行。 命令行输入 1python mange.py createsuperuser 邮箱可以不输入，按Enter跳过，但密码并不是不输入，而是输入了也不显示。 运行django命令行输入 1python mange.py runserver 网站中输入 127.0.01:8000 即可看到项目运行成功。 Django后台登录创建超级用户后，运行Django项目，进入网址 127.0.0.1:8000/admin 登录成功 1 记得帐号，但是忘记了密码 命令行输入 1python manage.py changepassword &lt;username&gt; username 是你的帐号。 这些你都懂？ 那么请看下面 djano小技巧]]></content>
      <categories>
        <category>Programme</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django小技巧]]></title>
    <url>%2F2018%2F08%2F12%2FDjango%E5%B0%8F%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[Django项目设置中文与本地时区在项目下的 settings.py 文件中进行设置，将 改为 运行项目打开网址即可 关于外键从Django2.0版本开始，在类模型中，定义外键和一对一关系字段时需要添加 on_delete 参数，不然会报错：__init__() missing 1 required positional argument: &#39;on_delete&#39;。 后台显示中文应用名、类名与字段名如何登陆Django后台? Django后台登录 在添加Django应用后，创建超级管理员账号可以登录Django自带的管理后台，比如我添加了一个名为blog的应用，登录后台后显示为 现在我们来将它修改为中文显示 在Django应用目录(即你添加的应用)下打开apps.py文件，在AppNameConfig类里添加两条属性即可，如图： 然后在blog应用目录下的__init__.py文件里添加一句 1default_app_config = &apos;AppName.apps.AppNameConfig&apos; 即可 例如在我的应用下这一句应为 1default_app_config = &apos;blog.apps.BlogConfig&apos; 在上图中可以看到在博客应用下有三个Model，分别为Categorys，Tag和Posts，现在来改为中文显示。 在定义上面三个Model的models.py文件夹里，修改对应的model类，如下图所示： 后面两个修改方式一样，修改之后刷新后台。 在此说一下 verbose_name 与 verbose_name_plural 的区别：以 Categorys 为例，可以看到该Model名后面有个 &#39;s&#39;，意为复数，所以如果只添加 verbose_name = ‘分类’， 则在后台显示会为 ‘分类s’。 在models.py中的model类中，通常会创建一些字段，一般会想要这些字段在后台为中文显示，方便识别。 显示为中文方法很简单，在定义该字段时添加 verbose_name 参数即可，例如： 反向查询与数量统计我在 Django 里写了两个 Model，一个是 Post（文章），一个是 Comment（评论），两者是一对多关系 Post是Comment 的外键，如图： 在视图中如果需要取出一篇文章的全部评论，可以这样写 post= get_object_or_404(Post, pk=pk) comment_list = Comment.objects.filter(post=post) 这是从所有评论中选出属于 post 文章的评论 现在来看另一种方法，直接查询某篇文章所有属于它的评论 post = get_object_or_404(Post, pk=pk) comment_list = post.comment_set.all() 当然，我们一般会在文章页统计评论数，应该怎么做呢？ 在模板文件中使用 1&#123;&#123; post.comment_set.count &#125;&#125; 即可。 （模型管理器comment_set 是一个特殊的模型管理器）还有一个count方法，返回数量 使用 annotate 新定义了一个Model叫 Category作为Post，在 Post里添加一个外键字段 现在我想获取 属于同一分类 category下的所有 post，由前面所说的方法我可以在这样写 1234# 在 views.py 中category_list = Category.objects.all()# 在模板中&#123;&#123; category.post_set.count &#125;&#125; 但是这样的话每调用一次都会访问一次数据库，那么 annotate 就派上用场了 1234567# 在views.py中category_list = Category.objects.annotate(num_posts=Count('post'))# 在模板中&#123;% for category in category_list %&#125; &#123;&#123; category.num_posts &#125;&#125;&#123;% endfor %&#125; 使用 annotate 只需访问一次数据库就可以了。 模板文件、静态文件与媒体资源在 Django2.1 中，如果你将模板文件、静态文件与媒体资源放在应用下，则在访问资源时，会自动寻找，无须进行设置。 创建文件时，文件名是固定写法 123templates # 模板文件static # 静态文件media # 媒体资源文件 例：放在应用 blog 下的模板文件 如果需要放在项目目录下，则需在 settings.py中进行设置 模板文件 templates路径添加 12345678910111213141516TEMPLATES = [ &#123; 'BACKEND': 'django.template.backends.django.DjangoTemplates', -'DIRS': [], +'DIRS': [os.path.join(BASE_DIR, 'templates')], 'APP_DIRS': True, 'OPTIONS': &#123; 'context_processors': [ 'django.template.context_processors.debug', 'django.template.context_processors.request', 'django.contrib.auth.context_processors.auth', 'django.contrib.messages.context_processors.messages', ], &#125;, &#125;,] 静态文件路径添加，在 settings.py 中的末尾添加 12345STATIC_PATH = os.path.join(BASE_DIR, 'static')STATICFILES_DIRS = ( STATIC_PATH,) 媒体资源路径添加 12MEDIA_URL = '/media/'MEDIA_ROOT = os.path.join(BASE_DIR, 'media') app应用设计开发环境在PyCharm下。 若一个django项目下有许多个app应用，那么我们肯定想要将他们它们放入同一个文件夹下，方便管理。 例： 我的django项目下有三个 appp应用，blog、users和comments 在项目目录下新建一个python package ，命名为 apps，将三个应用全部放入其中。 此时运行项目会报错，右键 apps 文件移到最下面选择 Mark Directory as点击Source Root，并在settings.py中设置 再次运行项目，就会成功了。 自定义模板标签django的模板标签自定义 models.py 123456789101112131415161718from django.db import models# Create your models here.# 分类class Category(models.Model): pass# 标签class Tag(models.Model): pass# 文章class Post(models.Model): pass 在应用目录下创建python package，名字必须为templatetags， 在该python包下自定义文件blog_tags.py 123456789101112131415161718192021222324252627282930313233343536# -*-coding:utf-8-*-# blog_tags.py__Author__ = "Mr.D"__Date__ = '2018\8\14 0014 21:26'from ..models import Post, Category, Tagfrom django import templateregister = template.Library()# 将该函数注册为模板标签，可通过&#123;% get_recent_posts %&#125;语法在模板中调用# 最新文章@register.simple_tagdef get_recent_posts(num=5): return Post.objects.all().order_by('-created_time')[:num]# 归档@register.simple_tagdef archives(): return Post.objects.dates('created_time', 'month', order='DESC')# 分类@register.simple_tagdef get_categories(): return Category.objects.all()@register.simple_tagdef get_tags(): return Tag.objects.all() 通过此方法可使上面三个函数作为模板语言在django模板中使用，在模板文件中导入 1&#123;% load blog_tags %&#125; 即可。 使用方法与一般模板语言一样。 自定义Django admin修改项目admin后台的 header 与 title 在 应用（任意一个）下的admin.py中添加 12admin.site.site_header = 'Black &amp; White'admin.site.site_title = admin.site.site_header 刷新一下后台 Django ORM 查询语句1234567891011121314151617# __gt 大于Model.objects.filter(count__gt=0)# __gte 大于等于Model.objects.filter(count__gte=0)# lt 小于Model.objects.filter(count__lt=0)# lte 小于等于Model.objects.filter(count__lte=0)# contains关键字，区分大小写Model.objects.filter(title_contains=q)# icontains 不区分大小写的关键字(contains)Model.objects.filter(title__icontains=q)]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo搭建博客错误解决]]></title>
    <url>%2F2018%2F08%2F06%2FHexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3%2F</url>
    <content type="text"><![CDATA[使用hexo搭建个人博客的过程中碰到了好多的坑，现在一一填上。 hexo的下载安装可参考 hexo安装 Hexo常用命令1234567891011# 创建文章$ hexo new &apos;xxx&apos;# 创建标签$ hexo new page tags# 创建分类$ hexo new page categories# 调试命令$ hexo s ## hexo s -p 5000 更换端口 在文章中插图片必须配置： 1 把主页配置文件_config.yml 里的post_asset_folder:这个选项设置为true 2 在你的hexo目录下执行这样一句话npm install hexo-asset-image --save，这是下载安装一个可以上传本地图片的插件。 3 运行hexo n &quot;xxxx&quot;来生成md博文时，/source/_posts文件夹内除了xxxx.md文件还有一个同名的文件夹。 两种方法： 1 使用Markdown 语法 1![对该图片的描述](同名文件夹名/图片名.jpg) 2 使用hexo自带插件 1&#123;% asset_img 图片名.png/jpg 对图片的描述写在这哦 %&#125; github仓库名必须与github用户名一致 使用 hexo s 时本地不显示博客内容，而显示 cannot get/xxx1$ hexo s -p 5000 换个端口即可。 设置语言为中文我最开始按照网站教程在站点配置文件_config.yml下的设置语言为中文 1language: zh-Hans 然而本地网站并没有换成中文。 因为在hexo的新版本中被更换了，改成 1language: zh-CN 即可。 配置LeanCloud，将阅读人数替换为热度参考： 配置LeanCloud 然而进入文章会出现这样的错误 &quot;Counter not initialized! See more at console err msg&quot; 解决方法参考：LearnCloud报错解决 添加阅读时长和本文字数博文压缩安装 gulp以及依赖包 123$ npm install --save-dev babel-cli$ npm install --save-dev babel-preset-es2015$ npm install gulp-minify-css gulp-babel gulp-uglify gulp-htmlmin gulp-htmlclean --save-dev 在博客的根目录创建新文件 gulpfile.js，添加如下代码 12345678910111213141516171819202122232425262728293031323334var gulp = require('gulp');var minifycss = require('gulp-minify-css');var babel = require('gulp-babel');var uglify = require('gulp-uglify');var htmlmin = require('gulp-htmlmin');var htmlclean = require('gulp-htmlclean');gulp.task('minify-css', function () &#123;return gulp.src('./public/**/*.css').pipe(minifycss()).pipe(gulp.dest('./public'));&#125;);gulp.task('minify-html', function () &#123;return gulp.src('./public/**/*.html').pipe(htmlclean()).pipe(htmlmin(&#123;removeComments: true,minifyJS: true,minifyCSS: true,minifyURLs: true,&#125;)).pipe(gulp.dest('./public'))&#125;);gulp.task('minify-js', function () &#123;return gulp.src(['./public/**/*.js', '!./public/**/*.min.js']).pipe(babel(&#123; presets: ['es2015'] &#125;)).pipe(uglify()).pipe(gulp.dest('./public'));&#125;);gulp.task('default', ['minify-html', 'minify-css', 'minify-js']); 执行 hexo g 产生编译文件之后，执行 gulp进行压缩，以下信息代表压缩成功 再执行 hexo d部署到服务器上即可。]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F08%2F06%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
